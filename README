yes, I am insane

Tired of waiting many miliseconds for linux_logo to run?
Tired of wasting 35k of disk space?
Upset that to run linux_logo you need huge GLIBC?

Well your worries are over!

With "ll"  [even the name was shortened to save space!] you get all of the
benefits of linux_logo in a smaller, faster package!

"ll" is written entirely in native Linux assembly language!


Some Statistics
---------------

     *NOTE*  not all architectures implement the same feature-set
       (IE, not all have MHz in /proc/cpuinfo) so this is only
       a rough comparison.


     Processor        lzss executable     old RLE executable
     ---------        ---------------     ------------------
     ia64		                      5736 bytes
     alpha		2013 bytes            4264 bytes
     s390	        1692 bytes            2844 bytes
     parisc		1432 bytes
     SPARC		1397 bytes            3708 bytes
     mips               1324 bytes
     PPC		1238 bytes            3228 bytes
     arm		1218 bytes
     x86_64		1001 bytes
     x86                 969 bytes            2636 bytes

     The various implementations have varying functunality and often
     use different methods to get system info.  Still, some gross
     comparisons between the architectures can be made.


Individual architectural comments, in descending order of executable size:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ia64:   ia64 is VLIW.
     
        The way the instruction set works you can have up to 3-instructions
	per "bundle" to parallelize things.  My code is not optimized and
	thus often wastes 2/3 of each "bundle".
	
	Also I have not moved it to the more compact LZSS logo method yet.

alpha:  
	Alpha is hurt because it implements some "optional" features,
	such as MHz (which added a lot of code) and also counting
	num of cpus, with proper pluralization of Processor.
	
	The *big* hurt though is lack of byte-manipulating instructions.

	The original alpha architecture did not support operations on bytes,
	you have to do a lot of shifting and masking.
	
	Unfortunately ll uses a lot of byte-sized memory operations.
     
        On the x86 the instruction "lodsb" is 1 byte in size.
        On the PPC the equivelant is "lbzu" which is 4 bytes in size.
        On the alpha, the instruction is "ldb" which expands to
           a "lda","ldq_u","extbl","sll","sra" sequence, plus
	   an add instruction that x86 and ppc do automatically.
	   Thus, taking 24 bytes.
	It's a bit better if you do an unsigned load, which is only 16
	   bytes, but still.

	A store byte actually does a 32-bit load, masks in the byte by
	  hand, and then does the actual 32-bit store :(

	The "jump if bit one set" type instructions help the lzss.

	The immediate field for ALU ops of only 8 bits really hurts
	
	There is no native integer division routine on alpha.

s390:   This is the most CISC architecture I've ever seen.  If only it had
	   a "load byte" opcode it would definitely beat out x86.  I am sure
	   it can be optimized even smaller than x86 by a s390 expert.
	   Being able to do "strcat" in 2 or 3 op-codes and strlen in not
	   more than 5 is a big plus.

parisc:	+ really hurt by its short immediate field.  Most addresses
	  require 2 instructions to load, even if try to use relative-data add.
	+ no integer divide, have to code it up... not so bad in loop form
        + delay slot that can be nulled out
	+ some ALU instructions can also null out following instructions 
          conditionally
	+ compare immediate instruction only can handle 5-bit immediate	
        + loads/stores must be aligned
	+ no AND immediate instruction

sparc:  
	Condition codes make for tighter code.
	register/register load address calcs also help.
	13-bit immdediate hurts a bit.

	SPARC is unfair a bit, because my test machine is a 24-proc
        niagara, so it has extra code to handle that many chips properly.

mips:   Recent binutils has made mips come in line with the
        other architectures.
	
	It is the most RISC of the RISC architectures.  Thus it ends
	up having a very non-dense instruction set.
	
	On the plus side, it has hardware support for unaligned loads,
	plus hardware integer divide, which help a lot.

ppc:	The PowerPC has very CISC-like opcodes as well.
        Despite being load-store with 3 operand instructions, you almost
	wouldn't know it was considered RISC.  I also think I could
	optimize the code a bit more and challenge x86.
	
	The big help is auto-incrementing load/store byte instructions.


arm:	no integer division routine
	Really painful to load constants > 8 bits that aren't powers of two or
	  else 8-bit values shifted by power of two.
	If we had integer divide, saner constant support, and  unaligned loads 
	  we could probably beat x86 even with 32 bit instructions.

x86_64: When doing a straight x86 -> x86_64 conversion (which involves making
        all of the push %e?? instructions into push %r??, as well as jmp *%edx
        into jmp *%rdx) makes the code 28 bytes longer, due to the "inc" 
	instruction becoming 2 bytes, and extra addr32 prefixes being added to
	various move instructions.

	Switching the syscalls to native syscalls is about neutral.
	You do have to make sure to save %ecx across syscalls then.

	The sad part is we have 8 extra regs, but can't use any of them
	because the extra byte prefix is a killer.

	Also added in a few bytes extra to print the name better
        (gratuitous spaces on some cpuinfos).  Also we have to
	handle 4GB of RAM so we lose a few bytes for a 64-bit load.



x86:    The x86 code is currently the smallest, mainly because I had a
        running contest for a while with Stephan Walter until
	we got it below 1k.  It does help that there are a lot of
	useful 1-byte instructions in the x86 command set, which give
	it an instant advantage over all of the RISC chips.
	
	Lack of alignment makes string manipulating programs (like ll) a lot
	easier, as you can store 16 and 32 bit values w/o having to worry
	if the string is properly aligned.

	

Features:
--------
    + Runs in 4 miliseconds, more than twice as fast as the 10 linux_logo 
      takes on a K6-2+ 450!
    + Takes up only 969 bytes when super-stripped!
  
     Amaze your enemies!  Impress your friends!


BUGS:
-----
	No pretty-printing: This means that your computer is reported just
                            as /proc/cpuinfo reports, ugly model-name, off 
			    MHz, and all.

	Possibly kernel-dependent:  I only tested this on 2.4 and 2.6 kernels.
                            The sysinfo() syscall changed between 2.2 and 2.4

Custom Logo:
------------

	Point the "ANSI_TO_USE" variable in the Makefile to any text
	or ansi file you want when building.


HOW TO HELP:
------------
	If you have a Linux box running on an unsupported architecture,
	offer the author a shell-account so he can create a version
	for your type of machine!

Useful Resources:
-----------------
        http://www.linuxassembly.org
	http://www.deater.net/weave/vmwprod/asm
	http://www.deater.net/weave/vmwprod/linux_logo

Thanks to:
----------
  Shellcoders.  You seem to be the only useful resource for
    linux assembly on the various platforms.

Special Thanks to:
------------------
	my lovely wife

AUTHOR:
-------
        Vince Weaver <vince _at_ deater.net>  http://www.deater.net/weave
