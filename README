yes, I am insane

Tired of waiting many miliseconds for linux_logo to run?
Tired of wasting 35k of disk space?
Upset that to run linux_logo you need huge GLIBC?

Well your worries are over!

With "ll"  [even the name was shortened to save space!] you get all of the
benefits of linux_logo in a smaller, faster package!

"ll" is written entirely in native Linux assembly language!


Some Statistics
---------------

     Processor         Stripped Size of executable
     ---------         ---------------------------
     ia64		     5736 bytes
     alpha		     4264 bytes
     SPARC		     3708 bytes	
     PPC		     3228 bytes
     x86                     2908 bytes

     The various implementations have varying functunality and often
     use different methods to get system info.  Still, some gross
     comparisons between the architectures can be made.

     Why is the ia64 code so huge?
     
        The way the instruction set works you can have up to 3-instructions
	per "bundle" to parallelize things.  My code is not optimized and
	thus often wastes 2/3 of each "bundle".

     Why is the alpha code so large?
     
        Unfortunately ll uses a lot of byte-sized loads and stores.
     
        On the x86 the instruction is "lodsb" which is 1 byte in size.
        On the PPC the instruction is "lbzu" which is 4 bytes in size.
        On the alpha, the instruction is "ldb" which expands to
           a "lda","ldq_u","extbl","sll","sra" sequence, plus
	   an add instruction that x86 and ppc do automatically.
	   Thus, taking 24 bytes.

     Why is x86 so small?

	Partly because I have lots of experience with x86 assembly and thus
	   I am best at optimizing that.  Mainly though it's because
	   x86 uses a variable-length instruction size, and while that's
	   crazy for the instruction-fetch hardware, it really does do wonders
	   for code size.

Features:
--------
    + Runs in 4 miliseconds, more than twice as fast as the 10 linux_logo 
      takes on a K6-2+ 450!
    + Takes up only 2.9k when stripped!  This is small enough to fit in 
      one 4k x86 memory page!
  
     Amaze your enemies!  Impress your friends!


BUGS:
-----
	No pretty-printing: This means that your computer is reported just
                            as /proc/cpuinfo reports, ugly model-name, off 
			    MHz, and all.

	Doesn't work on >1GB systems: This is because I was lazy and didn't
                                      want to do a 16bit divide in the 
				      binary->decimal converter.  If there's
				      enough demand I can probably fix this 
				      up in a few bytes.
			    
	Possibly kernel-dependent:  I only tested this on 2.4.x kernels.


Custom Logo:
------------

	Point the "ANSI_TO_USE" variable in the Makefile to any text
	or ansi file you want when building.


HOW TO HELP:
------------
	If you have a Linux box running on an unsupported architecture,
	offer the author a shell-account so he can create a version
	for your type of machine!

	Also you can offer the author a job doing Linux and/or assembly
	language stuff.  He had been working at BIOS programming on a Linux 
	web-pad for a company that no longer exists, but now all the EE jobs 
	on the US East coast seem to have vanished.
	
	Or maybe you could suggest a good US graduate school that 
	would take said author who only had a 2.9 GPA but comes with
	good reccomendations, GREs, and a love for EE stuff.

Useful Resources:
-----------------
        http://www.linuxassembly.org
	http://www.deater.net/weave/vmwprod/asm
	http://www.deater.net/weave/vmwprod/linux_logo

Special Thanks:
---------------
	to Kristina Gonser

AUTHOR:
-------
        Vince Weaver <vince@deater.net>  http://www.deater.net/weave
